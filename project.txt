---

`astro.config.mjs`:
```
import { defineConfig } from 'astro/config';
import netlify from '@astrojs/netlify';

import sitemap from '@astrojs/sitemap';

import icon from 'astro-icon';

export default defineConfig({
  image: {
    domains: ["googleusercontent.com"],
  },
  output: 'server',

  adapter: netlify({
    edgeMiddleware: false,
  }),

  integrations: [sitemap(), icon({
    include: {
      "material-symbols": ["*"],
    },
  }),],
});
```
---

`tsconfig.json`:
```
{
  "extends": "astro/tsconfigs/strict",
  "include": [".astro/types.d.ts", "**/*"],
  "exclude": ["dist"]
}

```
---

`src/env.d.ts`:
```
// env.d.ts
declare namespace App {
  interface Locals {
    email: string;
    name: string;
    avatar_url: string;
    userId: string;
    createdAt: string;
    school: string | undefined;
    phone: string | undefined;
    is_participant: boolean | undefined;
    is_visible: boolean | undefined;
  }
}
```
---

`src/types.ts`:
```
// src/types.ts
export interface Question {
  id: number;
  question: string;
  money: number | null;
  case: string | null;
}

export interface Answer {
  id: number;
  question_id: number;
  answer: number;
}
```
---

`src/components/AuthForm.astro`:
```
---
// src/components/AuthForm.astro
import LoginWithGoogleButton from './LoginWithGoogleButton.astro';

interface Props {
  showProviderButtons?: boolean;
}

const { showProviderButtons = false } = Astro.props;
---

{
  showProviderButtons && (
    <LoginWithGoogleButton buttonText="Log in with Google" />
  )
}

<style>
  .button{
        font-family: "Open Sans", sans-serif;
    }
</style>
```
---

`src/components/CompetitionAnnouncement.astro`:
```
---
import { Icon } from "astro-icon/components";
import Countdown from "./Countdown.astro";
import LoginWithGoogleButton from "./LoginWithGoogleButton.astro";
import Countdown2 from "./Countdown2.astro";

interface Props {
    isLoggedIn: boolean;
    isParticipant?: boolean;
}

const { isLoggedIn, isParticipant = false } = Astro.props;
---

<md-outlined-card class="card col" id="competition-card">
    <div class="main col">
        <Icon name="trophy2" size="2.5em" />&nbsp;
        Faraid Competition 2025
    </div>
    <div class="col">
        <p>Pendaftaran ditutup dalam:</p>
        <Countdown2 targetTime="2025-06-17T11:00:00Z" />
    </div>
    {
        isLoggedIn ? (
            isParticipant ? (
                <md-filled-button href="/competition">
                    VIEW COMPETITION
                </md-filled-button>
            ) : (
                <md-filled-button id="announcement-join-button">
                    JOIN COMPETITION
                </md-filled-button>
            )
        ) : (
            <LoginWithGoogleButton
                buttonType="filled"
                buttonText="JOIN"
                intent="join_competition"
            />
        )
    }
</md-outlined-card>

<script>
    import { navigate } from "astro:transitions/client";
    import "material/button/filled-button";
    import "material/card/outlined-card";
    import "material/card/elevated-card";
    import "material/card/filled-card";

    document.addEventListener("astro:page-load", () => {
        // Changed from DOMContentLoaded
        const closeButton = document.getElementById("close-button");
        const card = document.getElementById("competition-card");
        const joinButton = document.getElementById("announcement-join-button");
        if (closeButton && card) {
            closeButton.addEventListener("click", () => {
                card.style.display =
                    card.style.display === "none" ? "" : "none";
            });
        }
        if (joinButton) {
            joinButton.addEventListener("click", async (e) => {
                e.preventDefault();
                (joinButton as HTMLButtonElement).disabled = true;
                try {
                    const response = await fetch("/api/profile", {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({ is_participant: true }),
                    });
                    if (!response.ok) {
                        const errorData = await response.json();
                        alert(errorData.error || "Failed to join competition");
                        (joinButton as HTMLButtonElement).disabled = false;
                        return;
                    }
                    navigate("/competition");
                } catch (err) {
                    alert("An unexpected error occurred.");
                    (joinButton as HTMLButtonElement).disabled = false;
                }
            });
        }
    });
</script>
<style is:global>
    .countdown-container {
        font-size: 0.5em;
        gap: 0.5em;
    }
</style>
<style>
    .card {
        font-size: 1em;
        position: relative;
        padding: 18px;
        text-align: center;
        gap: 0.5em;
        font-weight: 500;
        max-width: 90%;
        justify-content: space-between;
        --_container-shape: 28px;
        --_container-color: var(--md-sys-color-surface-variant);
        backdrop-filter: blur(4px);
    }

    .main {
        font-size: 1.2em;
        gap: 0.5em;
        font-weight: bold;
    }

    .card > .col p {
        font-size: 0.5em;
        opacity: 0.5;
    }

    .close-button {
        position: absolute;
        top: 0.7em;
        right: 0.7em;
        background: none;
        border: none;
        cursor: pointer;
        padding: 0;
        z-index: 10;
        color: var(--md-sys-color-on-surface-variant);
        opacity: 0.5;
    }

    @media (min-width: 600px) {
         .card {
      font-size: 0.7em;
      flex-direction: row;
      align-items: center;
      gap: 1em;
      width: 60vw;
      position: fixed;
      bottom: 19vh;
      padding: 1em 2em;
    }

        .main {
            flex-direction: row;
            align-items: center;
        }
    }
</style>

```
---

`src/components/Countdown.astro`:
```
---
interface Props {
  targetTime: string;
  format?: "dhms" | "colon";
  labels?: {
    days?: string;
    hours?: string;
    minutes?: string;
    seconds?: string;
    finished?: string;
    space?: string; // For space between number and unit, default " "
  };
}

const { targetTime, format = "dhms", labels = {} } = Astro.props;

const targetDate: Date = new Date(targetTime);
const targetTimestamp: number = targetDate.getTime();

if (isNaN(targetTimestamp)) {
  console.error("Invalid targetTime prop:", targetTime);
}

// Define default labels and merge with provided ones
const defaultLabels = {
  days: format === "colon" ? ":" : "d", // Colon format doesn't use full labels for days
  hours: format === "colon" ? ":" : "h", // Colon format doesn't use full labels for hours
  minutes: format === "colon" ? ":" : "m",// Colon format uses colon as separator
  seconds: format === "colon" ? "" : "s",  // Colon format, seconds has no trailing unit/separator
  finished: "Countdown finished!",
  space: " ", // Default space between number and unit
};

const currentLabels = {
  days: labels.days !== undefined ? labels.days : defaultLabels.days,
  hours: labels.hours !== undefined ? labels.hours : defaultLabels.hours,
  minutes: labels.minutes !== undefined ? labels.minutes : defaultLabels.minutes,
  seconds: labels.seconds !== undefined ? labels.seconds : defaultLabels.seconds,
  finished: labels.finished !== undefined ? labels.finished : defaultLabels.finished,
  space: labels.space !== undefined ? labels.space : defaultLabels.space,
};

// For colon format, ensure separators are colons if not explicitly overridden for dhms context
const colonSeparators = {
    days: labels.days !== undefined && format === "colon" ? labels.days : (format === "colon" ? ":" : currentLabels.days),
    hours: labels.hours !== undefined && format === "colon" ? labels.hours : (format === "colon" ? ":" : currentLabels.hours),
    minutes: labels.minutes !== undefined && format === "colon" ? labels.minutes : (format === "colon" ? ":" : currentLabels.minutes),
    seconds: labels.seconds !== undefined && format === "colon" ? labels.seconds : (format === "colon" ? "" : currentLabels.seconds), // No separator after seconds in colon
};


---

{ !isNaN(targetTimestamp) && (
  <p
    class="countdown"
    data-target={targetTimestamp}
    data-format={format}
    data-label-days={format === "colon" ? colonSeparators.days : currentLabels.days}
    data-label-hours={format === "colon" ? colonSeparators.hours : currentLabels.hours}
    data-label-minutes={format === "colon" ? colonSeparators.minutes : currentLabels.minutes}
    data-label-seconds={format === "colon" ? colonSeparators.seconds : currentLabels.seconds}
    data-label-finished={currentLabels.finished}
    data-label-space={currentLabels.space}
  >
    <span class="countdown-text"></span>
  </p>
)}

<style>
  .countdown {
    font-size: 0.7em;
  }
</style>

<script>
  function updateCountdown(countdownElement: HTMLParagraphElement) {
    if (!countdownElement) {
      return;
    }

    const targetTimestamp = parseInt(countdownElement.dataset.target || '0', 10);
    const countdownTextSpan = countdownElement.querySelector('.countdown-text') as HTMLSpanElement;
    const format = countdownElement.dataset.format || "dhms";

    // Retrieve labels from data attributes
    const labelDays = countdownElement.dataset.labelDays || (format === "colon" ? ":" : "d");
    const labelHours = countdownElement.dataset.labelHours || (format === "colon" ? ":" : "h");
    const labelMinutes = countdownElement.dataset.labelMinutes || (format === "colon" ? ":" : "m");
    const labelSeconds = countdownElement.dataset.labelSeconds || (format === "colon" ? "" : "s");
    const labelFinished = countdownElement.dataset.labelFinished || 'Countdown finished!';
    const labelSpace = countdownElement.dataset.labelSpace || " ";


    if (!countdownTextSpan) { // Added a check for countdownTextSpan
        console.error("Countdown text span not found in", countdownElement);
        return;
    }

    if (isNaN(targetTimestamp)) {
      console.error("Invalid targetTimestamp:", countdownElement.dataset.target);
      countdownTextSpan.textContent = 'Invalid date';
      return;
    }

    const now: number = new Date().getTime();
    const timeLeft: number = targetTimestamp - now;

    if (timeLeft <= 0) {
      countdownTextSpan.textContent = labelFinished;
      const existingTimeoutId = parseInt(countdownElement.dataset.timeoutId || '0', 10);
      if (existingTimeoutId) {
        clearTimeout(existingTimeoutId);
        delete countdownElement.dataset.timeoutId; // Clean up
      }
      return;
    }

    const days: number = Math.floor(timeLeft / (1000 * 60 * 60 * 24));
    const hours: number = Math.floor((timeLeft % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
    const minutes: number = Math.floor((timeLeft % (1000 * 60 * 60)) / (1000 * 60));
    const seconds: number = Math.floor((timeLeft % (1000 * 60)) / 1000);

    let countdownString: string = "";

    if (format === "colon") {
      if (days > 0) {
        countdownString += `${days}${labelDays}`;
      }
      if (days > 0 || hours > 0) {
        countdownString += `${String(hours).padStart(2, '0')}${labelHours}`;
      }
      countdownString += `${String(minutes).padStart(2, '0')}${labelMinutes}`;
      countdownString += `${String(seconds).padStart(2, '0')}${labelSeconds}`;
    } else { // dhms format
       if (days > 0) {
          countdownString += `${days}${labelSpace}${labelDays}${labelSpace}`;
        }
        if (days > 0 || hours > 0) {
          countdownString += `${hours}${labelSpace}${labelHours}${labelSpace}`;
        }
        if (days > 0 || hours > 0 || minutes > 0) {
          countdownString += `${minutes}${labelSpace}${labelMinutes}${labelSpace}`;
        }
        countdownString += `${seconds}${labelSpace}${labelSeconds}`;
        countdownString = countdownString.trim();
    }

    countdownTextSpan.textContent = countdownString;
    const timeoutId = setTimeout(() => updateCountdown(countdownElement), 1000);
    countdownElement.dataset.timeoutId = String(timeoutId);
  }

  function initializeCountdowns() {
      const countdownElements = document.querySelectorAll('.countdown');
      countdownElements.forEach(element => {
        // --- THIS IS THE FIX ---
        const countdownElement = element as HTMLParagraphElement; // Cast to specific HTMLElement
        // --- END FIX ---

        // Clear any previous timeout if the element is being re-initialized
        const existingTimeoutId = parseInt(countdownElement.dataset.timeoutId || '0', 10);
        if (existingTimeoutId) {
            clearTimeout(existingTimeoutId);
            delete countdownElement.dataset.timeoutId; // Clean up dataset property
        }
        updateCountdown(countdownElement); // No need to cast again here
      });
  }

  document.addEventListener('astro:page-load', initializeCountdowns);
  // If using Astro View Transitions, also listen for astro:after-swap for MPA-like behavior
  // document.addEventListener('astro:after-swap', initializeCountdowns);
</script>
```
---

`src/components/Countdown2.astro`:
```
---
interface Props {
  targetTime: string;
  // You could add props for labels if you need them to be configurable, e.g.:
  // labelDays?: string;
  // labelHours?: string;
  // labelMinutes?: string;
  // labelSeconds?: string;
}

const { targetTime } = Astro.props;
// Example with configurable labels:
// const {
//   targetTime,
//   labelDays = "days",
//   labelHours = "hours",
//   labelMinutes = "minutes",
//   labelSeconds = "seconds"
// } = Astro.props;

const targetDate: Date = new Date(targetTime);
const targetTimestamp: number = targetDate.getTime();

if (isNaN(targetTimestamp)) {
  console.error("Invalid targetTime prop:", targetTime);
}
---

{ !isNaN(targetTimestamp) && (
  <div class="countdown-container" data-target={targetTimestamp}>
    <div class="countdown-block">
      <span class="countdown-value" data-unit="days">--</span>
      <span class="countdown-label">{/* labelDays || */ "hari"}</span>
    </div>
    <div class="countdown-block">
      <span class="countdown-value" data-unit="hours">--</span>
      <span class="countdown-label">{/* labelHours || */ "jam"}</span>
    </div>
    <div class="countdown-block">
      <span class="countdown-value" data-unit="minutes">--</span>
      <span class="countdown-label">{/* labelMinutes || */ "menit"}</span>
    </div>
    <div class="countdown-block">
      <span class="countdown-value" data-unit="seconds">--</span>
      <span class="countdown-label">{/* labelSeconds || */ "detik"}</span>
    </div>
    <div class="countdown-finished-message" style="display: none;">
      Countdown finished!
    </div>
  </div>
)}

{ isNaN(targetTimestamp) && (
  <p class="countdown-error">Invalid date provided for countdown.</p>
)}

<style>
  .countdown-container {
    display: flex;
    flex-wrap: wrap; /* Allows finished message to wrap */
    gap: 1em; /* Space between blocks */
    justify-content: center; /* Center blocks horizontally */
    font-family: 'Open Sans Variable', sans-serif;
    text-align: center;
    padding:1em;
  }
  .countdown-block {
    display: flex;
    flex-direction: column;
    align-items: center;
  }
  .countdown-value {
    font-size: 2.5em; /* Larger font for the number */
    font-weight:600;
    line-height: 1.1;
    color: var(--md-sys-color-primary);
    min-height: 1.2em; /* To prevent jump when numbers appear */
  }
  .countdown-label {
    font-size: 0.8em;
    text-transform: uppercase;
    color: var(--md-sys-color-on-surface-variant);
    margin-top: 0.3em;
  }
  .countdown-finished-message {
    width: 100%; /* Takes full width on its own line */
    margin-top: 1em;
    font-size: 1.2em;
    font-weight: bold;
    color: #333;
  }
  .countdown-error {
    color: red;
    font-style: italic;
  }
</style>

<script>
  function updateCountdownBlocks(countdownElement: HTMLElement) {
    if (!countdownElement) return;

    const targetTimestamp = parseInt(countdownElement.dataset.target || '0', 10);

    const daysSpan = countdownElement.querySelector('[data-unit="days"]') as HTMLSpanElement | null;
    const hoursSpan = countdownElement.querySelector('[data-unit="hours"]') as HTMLSpanElement | null;
    const minutesSpan = countdownElement.querySelector('[data-unit="minutes"]') as HTMLSpanElement | null;
    const secondsSpan = countdownElement.querySelector('[data-unit="seconds"]') as HTMLSpanElement | null;
    const finishedMessageDiv = countdownElement.querySelector('.countdown-finished-message') as HTMLDivElement | null;

    if (!daysSpan || !hoursSpan || !minutesSpan || !secondsSpan || !finishedMessageDiv) {
      console.error("Countdown component's internal elements not found!");
      return;
    }

    if (isNaN(targetTimestamp)) {
      console.error("Invalid targetTimestamp in dataset:", countdownElement.dataset.target);
      daysSpan.textContent = 'ERR';
      hoursSpan.textContent = 'ERR';
      minutesSpan.textContent = 'ERR';
      secondsSpan.textContent = 'ERR';
      return;
    }

    const now: number = new Date().getTime();
    const timeLeft: number = targetTimestamp - now;

    if (timeLeft <= 0) {
      daysSpan.textContent = '0';
      hoursSpan.textContent = '00';
      minutesSpan.textContent = '00';
      secondsSpan.textContent = '00';
      finishedMessageDiv.style.display = 'block';
      // Stop the recursive setTimeout
      return;
    }

    // Ensure finished message is hidden if countdown is active
    finishedMessageDiv.style.display = 'none';

    const days: number = Math.floor(timeLeft / (1000 * 60 * 60 * 24));
    const hours: number = Math.floor((timeLeft % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
    const minutes: number = Math.floor((timeLeft % (1000 * 60 * 60)) / (1000 * 60));
    const seconds: number = Math.floor((timeLeft % (1000 * 60)) / 1000);

    daysSpan.textContent = String(days);
    // Pad hours, minutes, and seconds with a leading zero if they are single digit
    // The example "12 4 7 8" shows single digits for H, M, S if < 10.
    // If you prefer "12 04 07 08", use .padStart(2, '0') for hours, minutes, seconds.
    // For this example, let's match the single-digit style if not large.
    // However, for consistency, padding is often better. I'll use padding.
    hoursSpan.textContent = String(hours).padStart(2, '0');
    minutesSpan.textContent = String(minutes).padStart(2, '0');
    secondsSpan.textContent = String(seconds).padStart(2, '0');

    setTimeout(() => updateCountdownBlocks(countdownElement), 1000);
  }

  // Run the script for all countdowns on page load and after view transitions
  function initCountdowns() {
    const countdownElements = document.querySelectorAll('.countdown-container');
    countdownElements.forEach(element => {
      // Check if already initialized to prevent multiple timeouts on HMR or view transitions
      if (!(element as HTMLElement).dataset.initialized) {
        updateCountdownBlocks(element as HTMLElement);
        (element as HTMLElement).dataset.initialized = 'true';
      }
    });
  }

  document.addEventListener('astro:page-load', initCountdowns);
  // If you are using View Transitions, you might also want 'astro:after-swap'
  // document.addEventListener('astro:after-swap', initCountdowns);
</script>
```
---

`src/components/Footer.astro`:
```
---
import { Icon } from "astro-icon/components";

const socialMedia = [
    { name: "fa6-brands:square-twitter", url: "https://x.com/" },
    { name: "fa6-brands:square-facebook", url: "https://facebook.com/" },
    { name: "fa6-brands:square-whatsapp", url: "https://wa.me/966558066420" },
    { name: "fa6-brands:telegram", url: "https://t.me/966558066420" },
];
---

<footer class="col">
    <div class="icons">
        {
            socialMedia.map((social) => (
                <a
                    href={social.url}
                    target="_blank"
                    rel="noopener noreferrer"
                    aria-label={`Link to our ${social.name.split(":")[1]} page`}
                >
                    <Icon name={social.name} size={12} />
                </a>
            ))
        }
    </div>
    
    <div class="copy">© 2025, Faraid Academy. All rights reserved.</div>
    <div class="legal-links row">
        <a href="/terms">Terms of Service</a>
        <span>•</span>
        <a href="/privacy">Privacy Policy</a>
    </div>
</footer>

<style>
    footer {
        position: absolute;
        bottom: 0;
        padding: 0.5em;
        opacity: 0.5;
        /* Ensure footer spans width if not already */
        width: 100%;
        box-sizing: border-box;
        display: flex; /* To align items if needed */
        flex-direction: column; /* Stack items vertically */
        align-items: center; /* Center items horizontally */
        text-align: center; /* Center text */
        gap: 0.1em; /* Add some gap between elements */
    }
    .icons {
        display: flex;
        gap: 0.5em;
    }
    .icons a {
        color: inherit;
        text-decoration: none;
        transition: color 0.2s ease;
        display: inline-block;
    }
    .icons a:hover {
        color: #007bff; /* Or your theme's link hover color */
        transform: scale(1.1);
    }

    .legal-links { /* Style for the new legal links container */
        font-size: 0.3em; /* Adjust as needed */
        gap: 0.5em; /* Space between links and separator */
    }

    .legal-links a {
        color: inherit; /* Inherit color from footer */
        text-decoration: underline; /* Common for legal links */
    }

    .legal-links a:hover {
        text-decoration: none;
    }

    .copy{
        font-size:0.5em;
    }
</style>
```
---

`src/components/Form.astro`:
```
---
// src/components/Form.astro
import { Icon } from "astro-icon/components";

//Form.astro
interface Props {
    userName?: string;
    userSchool?: string;
    userPhone?: string;
    userGender?: string;
    userIsVisible?: boolean;
}

const {
    userName = "",
    userSchool = "",
    userPhone = "",
    userGender = "",
    userIsVisible = false,
} = Astro.props;
---

<md-dialog class="dialog" id="edit-profile">
    <div slot="headline">
        <Icon name="material-symbols:edit-square-rounded" /> Edit Profil
    </div>

    <form slot="content" id="form-id" method="dialog">
        <md-outlined-text-field
            label="Nama Lengkap"
            required
            minlength="4"
            value={userName}
            name="name"><Icon name="material-symbols:person-rounded" slot="leading-icon" /></md-outlined-text-field>
        <md-outlined-text-field
            label="Universitas/Sekolah"
            required
            minlength="4"
            value={userSchool}
            name="school"><Icon name="material-symbols:school-rounded" slot="leading-icon" /></md-outlined-text-field>
        <md-outlined-text-field
            label="Nomor Telefon"
            required
            minlength="4"
            type="tel"
            value={userPhone}
            name="phone"><Icon name="material-symbols:phone-in-talk-rounded" slot="leading-icon" />
        </md-outlined-text-field>

            <div class="gender row">
                <div class="row">
                    <md-radio id="male-radio" name="gender" value="male" checked={userGender === 'male'}></md-radio>
                    <label for="male-radio">Male</label>
                </div>
                <div class="row">
                    <md-radio id="female-radio" name="gender" value="female" checked={userGender === 'female'}></md-radio>
                    <label for="female-radio">Female</label>
                </div>
            </div>
<md-divider></md-divider>

        <label>
            <md-checkbox
                name="is_visible"
                touch-target="wrapper"
                checked={userIsVisible}
                value="true"
            >
            </md-checkbox><span>Tampilkan nama Anda di daftar peserta</span>
        </label>
    </form>

    <div slot="actions">
        <md-filled-button form="form-id" id="submit-button"
            >SIMPAN</md-filled-button
        >
    </div>

</md-dialog>

<script>
    import { navigate } from 'astro:transitions/client';
    import "material/textfield/outlined-text-field";
    import "material/button/filled-button";
    import "material/dialog/dialog";
    import "material/checkbox/checkbox";
    import "material/radio/radio";
    import "material/divider/divider"

    const submitButton = document.getElementById("submit-button");
    const form = document.getElementById("form-id") as HTMLFormElement;
    const dialog = document.querySelector("#edit-profile") as any;

    const submitProfileForm = async (event: Event) => {
        event.preventDefault();

        const name = (form.querySelector('[name="name"]') as HTMLInputElement)
            .value;
        const school = (
            form.querySelector('[name="school"]') as HTMLInputElement
        ).value;
        const phone = (form.querySelector('[name="phone"]') as HTMLInputElement)
            .value;
        const isVisible =
            (form.querySelector('[name="is_visible"]') as HTMLInputElement)
                ?.checked || false;
        const genderElement = form.querySelector('[name="gender"]:checked') as HTMLInputElement;
        const gender = genderElement ? genderElement.value : '';
        console.log("Gender:", gender)

        if (!form.checkValidity()) {
            form.reportValidity();
            return;
        }

        try {
            const response = await fetch("/api/profile", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                },
                body: JSON.stringify({
                    name,
                    school,
                    phone,
                    gender,
                    is_visible: isVisible,
                }),
            });

            if (!response.ok) {
                const errorData = await response.json();
                alert(
                    `Error updating profile: ${errorData.error} - ${errorData.details}`,
                );
                return;
            }

            dialog.close();
            navigate(window.location.pathname, { history: 'replace' });
        } catch (error) {
            console.error("Error updating profile:", error);
            alert("An unexpected error occurred.");
        }
    };

    if (submitButton) {
        submitButton.addEventListener("click", submitProfileForm);
    }
</script>

<style>
    .dialog {
        flex-direction: column;
        margin: auto;
        height: min-content;
        position: absolute;
    }

    #form-id {
        display: flex;
        flex-direction: column;
        gap: 1em;
    }

    label{
        display: flex;
        align-items: center;
        gap: 0.5em;
    }

    label span strong {
        display: inline;
        text-wrap: pretty;
    }

    label{
        padding: 5px;
    }

    .competition-checkbox{
        padding: 5px;
        background-color: var(--md-sys-color-primary-container);
        color: var(--md-sys-color-on-primary-container);
        border-radius: 8px;
    }

    .gender{
                justify-content: space-between;
            }
</style>
```
---

`src/components/Header.astro`:
```
---
import "@fontsource-variable/eb-garamond";
import { Icon } from "astro-icon/components";
import ThemeIcon from "./ThemeIcon.astro";
import Navbar from "./Navbar.astro";
import NavStrip from "./NavStrip.astro";
import LoginWithGoogleButton from './LoginWithGoogleButton.astro';
import UserAvatar from './UserAvatar.astro'; // Import the new component

interface Props {
    isLoggedIn: boolean;
}

const { isLoggedIn } = Astro.props;
const { avatar_url, name } = Astro.locals;
---

<header>
    <a href="/">
        <div class="main">
            <Icon name="Logo" size="1.5em" />
            <h1>FaraidAcademy</h1>
        </div>
    </a>
    <div class="nav row">
        <NavStrip />
        <ThemeIcon />
		
        {
            isLoggedIn ? (
                avatar_url ? (
                    <a href="/dashboard">
                        <UserAvatar
                            src={avatar_url}
                            alt={name ? `${name}'s avatar` : "User Avatar"}
                            width={32}
                            height={32}
                        />
                    </a>
                ) : (
                    <a href="/dashboard">Dashboard</a>
                )
            ) : (
                <LoginWithGoogleButton buttonText="LOGIN" />
            )
        }
        <Navbar />
    </div>
</header>

<script>
    import "material/button/text-button";
</script>

<style>
    header {
        font-family: "EB Garamond Variable", serif;
        display: flex;
        flex-direction: row;
        align-items: center;
        gap: 0.3em;
        position: fixed;
        top: 0;
        padding: 1em;
        justify-content: space-between;
        width: 100%;
        background-color: transparent;
        z-index: 100;
    }


    .main {
        display: flex;
        flex-direction: row;
        align-items: center;
        gap: 0.5em;
        font-size: 1em;
    }

    h1 {
        font-weight: 500;
        font-size: 1em;
    }

    header a {
        display: flex;
        text-decoration: none;
        color: inherit;
        height: min-content;
    }
    .nav {
        width: min-content;
        height: min-content;
        gap: 1em;
		display: flex;
        font-size: 0.8em;
    }

    .button {
        font-family: "Open Sans", sans-serif;
    }
</style>
```
---

`src/components/LoginWithGoogleButton.astro`:
```
---
interface Props {
  buttonType?: 'text' | 'filled' | 'outlined'; // Material types
  buttonText: string;
  class?: string; // Allow passing additional classes
  intent?: string; // Add this
}
const { buttonType = 'text', buttonText, class: className, intent } = Astro.props; // Add intent
---
<form action="/api/auth/signin" method="post" class:list={[className]}>
  {intent && <input type="hidden" name="intent" value={intent} />} {/* Add this line */}
  {buttonType === 'text' && (
    <md-text-button class="button" name="provider" value="google" type="submit">
      {buttonText}
    </md-text-button>
  )}
  {buttonType === 'filled' && (
    <md-filled-button class="button" name="provider" value="google" type="submit">
      {buttonText}
    </md-filled-button>
  )}
  {buttonType === 'outlined' && (
    <md-outlined-button class="button" name="provider" value="google" type="submit">
      {buttonText}
    </md-outlined-button>
  )}
</form>

<script>
  import "material/button/text-button";
  import "material/button/filled-button";
  import "material/button/outlined-button";
</script>

<style>
.button {
  font-family: "Open Sans Variable", sans-serif;
}
form {
  display: inline-block;
}
</style>

```
---

`src/components/Navbar.astro`:
```
---
import { Icon } from "astro-icon/components";

import { links } from "../data/links";
---

<nav>
    <Icon
        name="material-symbols:menu-rounded"
        size="2em"
        id="menu-toggle"
        aria-expanded="false"
        aria-controls="nav-links"
        aria-label="Toggle navigation"
    />
    <div id="nav-links" class="hidden col">
        {
            links.map((link) => (
                <a class="col" href={link.href}>
                    {link.text}
                </a>
            ))
        }
    </div>
</nav>

<script>
    const menuToggle = document.getElementById("menu-toggle");
    const navLinks = document.getElementById("nav-links");

    if (menuToggle && navLinks) {
        menuToggle.addEventListener("click", () => {
            const isExpanded =
                menuToggle.getAttribute("aria-expanded") === "true";
            menuToggle.setAttribute("aria-expanded", String(!isExpanded));
            navLinks.classList.toggle("hidden");
        });
    }
</script>

<style>
    nav {
        display: flex;
        align-items: center;
        justify-content: space-between;
        width: 100%;
    }

    #nav-links {
        position: absolute;
        top: 100%;
        left: 0;
        width: 100%;
        background-color: var(--md-sys-color-background-variant);
        box-shadow: 0px 3px 3px rgba(0, 0, 0, 0.1);
        z-index: 1;
        transition: transform 0.3s ease-in-out;
        transform-origin: top;
        padding: 1em 0;

        font-size: 1.5em;
    }

    #nav-links.hidden {
        transform: scaleY(0);
    }

    #nav-links a {
        align-items: center;
        width: 100%;
        text-decoration: none;
        color: inherit;
        padding: 0.5em 0;
    }

    #menu-toggle{
        z-index: 12;
    }

    .hidden {
        display: none;
    }

    @media (min-width: 600px) {
        nav {
            display: none;
        }
    }
</style>

```
---

`src/components/NavStrip.astro`:
```
---
import { links } from "../data/links";
---

<nav>
    <div id="nav" class="row">
            {
                links.map((link) => ( 
                        <a href={link.href}>{link.text}</a>
                ))
            }
    </div>
</nav>

<style>
    #nav{
        display: none;
        font-size: 0.8em;
        gap: 1em;

    }
    #nav > a:first-child {
    font-weight: bold;
}
    a{
        font-style: none;
        color: var(--md-sys-color-on-surface);
        text-decoration: none;
    }

    @media (min-width: 600px) {
    #nav {
      display: flex;
    }
  }
</style>
```
---

`src/components/Profile.astro`:
```
---
import { Icon } from "astro-icon/components";
import UserAvatar from './UserAvatar.astro'; // Import the new component

const {
  email,
  name,
  avatar_url,
  createdAt,
  school,
  phone,
  is_participant,
  is_visible,
} = Astro.locals;

function formatDate(dateString: string | undefined) {
  if (!dateString) {
    return "Unknown";
  }
  const date = new Date(dateString);
  return date.toLocaleDateString("id-ID", {
    weekday: "long",
    year: "numeric",
    month: "long",
    day: "numeric",
  });
}
---

<md-elevated-card class="card col">
  <div class="main col">
    {
      avatar_url && (
        <UserAvatar
          src={avatar_url}
          alt={name ? `${name}'s avatar` : "User Avatar"}
          width={64}
          height={64}
        />
      )
    }

    <div class="name-badge col">
      <p class="name">{name || email}</p>
      {
        is_participant && (
          <div class="badge row data">
            <Icon name="material-symbols:verified-rounded" size="1.2em" />{" "}
            Peserta Kompetisi Faraid 2025
          </div>
        )
      }
    </div>
  </div>

  <div class="details col">
    {
      school && (
        <p class="data school row">
          <Icon name="material-symbols:school-rounded" /> {school}
        </p>
      )
    }
    {
      phone && (
        <p class="data row">
          <Icon name="material-symbols:phone-forwarded-rounded" /> {phone}
        </p>
      )
    }

    <p class="data row">
      <Icon name="material-symbols:person-rounded" />
      {formatDate(createdAt)}
    </p>
    {
      !is_participant && (
        <md-filled-button id="join-competition-profile-button">
          Join Faraid Competition 2025
        </md-filled-button>
      )
    }
  </div>

  <md-text-button id="edit-profile-button"
    ><Icon slot="icon" name="material-symbols:edit-square-rounded" /> EDIT PROFIL</md-text-button
  >
</md-elevated-card>

<style>
  .card {
    padding: 1.5em;
    gap: 1em;
  }

  .badge {
    font-size: 0.6em;
    padding: 5px 12px;
    color: var(--md-sys-color-on-primary-container);
    background-color: var(--md-sys-color-primary-container);
    border-radius: 999px;
  }

  .name-badge {
    gap: 0.5em;
  }

  .name {
    font-size: 1.5em;
    font-weight: 600;
    text-wrap: pretty;
    text-align: center;
  }

  .school {
    font-size: 1.1em;
    font-weight: 600;
  }

  .details {
    font-size: 0.7em;
    gap: 0.5em;
  }

  .data {
    gap: 0.5em;
  }

  /* Removed .avatar style as it's now in UserAvatar.astro */

  md-text-button {
    font-family: "Open Sans Variable", sans-serif;
  }

  #join-competition-profile-button {
    margin-top: 1em;
  }

  [data-icon] {
    color: inherit;
  }

  #edit-profile-button{
    opacity: 0.8;
    margin: 1em 0 0 0;
  }
</style>

<script>
  import { navigate } from "astro:transitions/client";
  import "material/button/text-button";
  import "material/button/filled-button";
  import "material/card/elevated-card";

  const editProfileButton = document.getElementById("edit-profile-button");
  const dialog = document.querySelector("#edit-profile") as any;

  if (editProfileButton && dialog) {
    editProfileButton.addEventListener("click", () => {
      if (typeof dialog.show === "function") {
        dialog.show();
      } else {
        dialog.open = true;
      }
    });
  }

  document.addEventListener("astro:page-load", () => {
    const joinButton = document.getElementById(
      "join-competition-profile-button",
    );
    if (joinButton) {
      joinButton.addEventListener("click", async (e) => {
        e.preventDefault();
        (joinButton as HTMLButtonElement).disabled = true;
        try {
          const response = await fetch("/api/profile", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ is_participant: true }),
          });
          if (!response.ok) {
            const errorData = await response.json();
            alert(errorData.error || "Failed to join competition");
            (joinButton as HTMLButtonElement).disabled = false;
            return;
          }
          navigate(window.location.pathname, { history: "replace" });
        } catch (err) {
          alert("An unexpected error occurred.");
          (joinButton as HTMLButtonElement).disabled = false;
        }
      });
    }
  });
</script>
```
---

`src/components/ThemeIcon.astro`:
```
---
// src/components/ThemeIcon.astro
import { Icon } from "astro-icon/components";
---

<button id="themeToggle" aria-label="Toggle Theme">
  <Icon name="material-symbols:light-mode-rounded" data-icon="light-icon" />
  <Icon name="material-symbols:dark-mode-rounded" data-icon="dark-icon" />
</button>

<style>
  #themeToggle {
    border: none;
    background: none;
    cursor: pointer;
    padding: 0;
    color: var(--md-sys-color-on-surface);
    font-size: 1.5rem;
  }

  /* Light theme: show light, hide dark */
  :global(.light) [data-icon="dark-icon"] {
    display: flex;
  }
  :global(.light) [data-icon="light-icon"] {
    display: none;
  }

  /* Dark theme: hide light, show dark */
  :global(.dark) [data-icon="dark-icon"] {
    display: none;
  }
  :global(.dark) [data-icon="light-icon"] {
    display: flex;
  }
</style>

<script is:inline>
  document.addEventListener('astro:page-load', () => {
  const theme = (() => {
    const localStorageTheme = localStorage.getItem("theme");
    if (localStorageTheme === "dark" || localStorageTheme === "light") {
      return localStorageTheme;
    }
    if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
      return 'dark';
    }
    return 'light';
  })();

  function applyTheme(currentTheme) {
    const root = document.documentElement;
    if (currentTheme === "dark") {
      root.classList.add("dark");
      root.classList.remove("light");
    } else {
      root.classList.add("light");
      root.classList.remove("dark");
    }
    localStorage.setItem("theme", currentTheme);
  }

  applyTheme(theme);

  const handleToggleClick = () => {
    const element = document.documentElement;
    let isDark;
    if (element.classList.contains("dark")) {
      isDark = false;
    } else {
       isDark = true;
    }

    applyTheme(isDark ? "dark" : "light");
  };

  document.getElementById("themeToggle")?.addEventListener("click", handleToggleClick);});
</script>
```
---

`src/components/UserAvatar.astro`:
```
---
// src/components/UserAvatar.astro
import { Image } from "astro:assets";

interface Props {
  src: string | undefined | null; // Allow src to be undefined or null
  alt: string;
  width: number;
  height: number;
  class?: string; // Allow passing additional classes
}

const { src: originalSrc, alt, width, height, class: className } = Astro.props;
const defaultAvatarPath = "/images/default-avatar.png"; // Path relative to your `public` folder

let effectiveSrc = defaultAvatarPath; // Default to the fallback image

if (originalSrc && typeof originalSrc === 'string' && originalSrc.trim() !== '') {
  if (originalSrc.startsWith("https://lh3.googleusercontent.com")) {
    let isGoogleUrlAccessible = false;
    try {
      // Set a timeout for the check to prevent long delays during server render
      const controller = new AbortController();
      const timeoutDuration = 3000; // 3 seconds
      const timeoutId = setTimeout(() => controller.abort(), timeoutDuration);

      // Use a HEAD request to check accessibility without downloading the full image.
      // This is lighter than a GET request.
      const response = await fetch(originalSrc, {
        method: 'HEAD',
        signal: controller.signal,
      });
      
      clearTimeout(timeoutId); // Clear the timeout if fetch completes

      if (response.ok) {
        isGoogleUrlAccessible = true;
      } else {
        console.warn(`UserAvatar: HEAD request for Google avatar ${originalSrc} failed with status ${response.status}. Using fallback.`);
      }
    } catch (error: any) {
      if (error.name === 'AbortError') {
        console.warn(`UserAvatar: HEAD request for Google avatar ${originalSrc} timed out. Using fallback.`);
      } else {
        console.warn(`UserAvatar: Error during HEAD request for Google avatar ${originalSrc}: ${error.message}. Using fallback.`);
      }
      // isGoogleUrlAccessible remains false
    }

    if (isGoogleUrlAccessible) {
      effectiveSrc = originalSrc;
    }
    // If not accessible, effectiveSrc remains defaultAvatarPath
  } else {
    // If originalSrc is provided but not a Google URL, use it directly.
    // Astro's <Image> component will handle it (and error if it's an unauthorized remote domain).
    effectiveSrc = originalSrc;
  }
}
// If originalSrc was null, undefined, or an empty string, effectiveSrc remains defaultAvatarPath.

---

<Image
  class:list={["avatar-component", className]}
  src={effectiveSrc}
  alt={alt}
  width={width}
  height={height}
  format="webp"
  quality={effectiveSrc === defaultAvatarPath ? 90 : 75} 
  loading="lazy"
/>

<style>
  .avatar-component {
    border-radius: 50%;
    object-fit: cover;
    border: 2px solid var(--md-sys-color-outline-variant);
  }
</style>
```
---

`src/components/WelcomeCompetitionPrompt.astro`:
```
---
import "material/dialog/dialog";
import "material/button/filled-button";
import "material/button/text-button";
import { Icon } from "astro-icon/components";

interface Props {
  userName: string;
  isParticipant: boolean | undefined;
}
const { userName, isParticipant } = Astro.props;
---

{
  !isParticipant && (
    <md-dialog id="competition-welcome-dialog">
      <div slot="headline">Selamat datang, {userName}</div>
      <div slot="content">
        Apakah anda ingin berpartisipasi dalam <br />{" "}
        <>
          <Icon name="trophy2a" />
          <strong> Faraid Competition 2025</strong>
        </>
        ?
      </div>
      <div slot="actions">
        <md-filled-button id="prompt-join-competition">Ya</md-filled-button>
        <md-text-button id="prompt-dismiss-competition">
          Mungkin nanti
        </md-text-button>
      </div>
    </md-dialog>
  )
}
<script>
  import { navigate } from 'astro:transitions/client';
  import "material/dialog/dialog";
  import "material/button/filled-button";
  import "material/button/text-button";

  // Define a type for dialog elements that might have MWC or native dialog APIs
  type DialogLikeElement = HTMLElement & {
    open?: boolean;
    show?: () => void; // Common in MWC
    showModal?: () => void; // Native dialog
    close: (reason?: string) => void;
  };

  document.addEventListener("astro:page-load", () => {
    const dialog = document.getElementById(
      "competition-welcome-dialog",
    ) as DialogLikeElement | null;
    const joinBtn = document.getElementById("prompt-join-competition");
    const dismissBtn = document.getElementById("prompt-dismiss-competition");

    if (dialog && !window.localStorage.getItem("competitionPromptDismissed")) {
      if (typeof dialog.show === "function") {
        dialog.show(); // Prefer MWC .show()
      } else if (typeof dialog.showModal === "function") {
        dialog.showModal();
      } else {
        dialog.open = true;
      }
    }

    if (joinBtn && dialog) {
      joinBtn.addEventListener("click", async () => {
        (joinBtn as HTMLButtonElement).disabled = true;
        try {
          const response = await fetch("/api/profile", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ is_participant: true }),
          });
          if (!response.ok) {
            const errorData = await response.json();
            alert(errorData.error || "Failed to join competition");
            (joinBtn as HTMLButtonElement).disabled = false;
            return;
          }
          // Successfully joined
          if (typeof dialog.close === "function") {
            dialog.close(); // Close the dialog before reloading
          }
          navigate(window.location.pathname, { history: 'replace' });
        } catch (err) {
          alert("An unexpected error occurred.");
          (joinBtn as HTMLButtonElement).disabled = false;
        }
      });
    }

    if (dismissBtn && dialog) {
      dismissBtn.addEventListener("click", () => {
        window.localStorage.setItem("competitionPromptDismissed", "true");
        if (typeof dialog.close === "function") {
          dialog.close();
        }
      });
    }
  });
</script>
<style>
  #competition-welcome-dialog {
    z-index: 1000;
    margin: auto;
  }
</style>

```
---

`src/content/guides/competition-guide.md`:
```
---
title: Panduan Kompetisi
---

**1. Baca dengan Seksama:** Pastikan Anda memahami setiap soal secara menyeluruh sebelum memilih jawaban.

**2. Detail dan Manajemen Waktu:**
    Kompetisi ini terdiri dari **sekitar 50 soal**.
    Total waktu pengerjaan adalah **sekitar 1.5 jam (90 menit)**.
    Atur waktu pengerjaan Anda dengan baik. Informasi mengenai sisa waktu akan ditampilkan selama kompetisi.

**3. Simpan Otomatis:** Jawaban yang Anda pilih untuk setiap soal akan tersimpan secara otomatis saat Anda mengeklik salah satu pilihan. Anda dapat mengubah jawaban Anda kapan saja sebelum waktu berakhir.

**4. Navigasi:** Gunakan tombol panah di bagian bawah setiap halaman soal untuk berpindah antar soal. Anda dapat kembali ke soal sebelumnya untuk meninjau atau mengubah jawaban.

**5. Pengumpulan Jawaban:** Tidak ada tombol "Kirim Semua" di akhir. Ketika Anda sudah menjawab semua soal, walaupun tidak berurutan, jawaban Anda akan dianggap final saat waktu kompetisi berakhir atau jika Anda menyelesaikan semua soal sebelum waktu habis.

**6. Seleksi ke Babak Final:** Peserta dengan skor tertinggi akan lolos ke babak final.

**7. Muraqabah:** Ini adalah kompetisi individual. Harap menjunjung tinggi sportivitas dan kejujuran selama kompetisi berlangsung.

**بارك الله فيكم**
```
---

`src/data/links.js`:
```
// src/data/links.js
export const links = [
    { href: "/competition", text: "Competition" },
    { href: "/dashboard", text: "Dashboard" },
  ];
```
---

`src/layout/ArticleLayout.astro`:
```
---
// src/layouts/ArticleLayout.astro
import Base from "./Base.astro"; // Import the Base layout

interface Props {
  title: string;
  // You can add other props if needed for articles, like 'description', 'publishDate', etc.
}

const { title } = Astro.props;
---

<Base title={title}>
  <main class="article-content">
    <article>
      <slot />
    </article>
  </main>
</Base>
<style is:global>
  body {
    background-color: white;
    background-image: none;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: flex-start;
  }
</style>
<style>
  .article-content {
    width: 100%;
    height: 90%;
    margin: 2em auto;
    padding: 2em;
    background-color: var( --md-sys-color-surface-container-lowest );
    border-radius: 8px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.05);
    line-height: 1.7;
    color: var(--md-sys-color-on-surface);
    overflow: auto;
    font-size: 1rem;
}

  .article-content > article {
    display: flex;
    flex-direction: column;
  }

  .article-content h1,
  .article-content h2,
  .article-content h3 {
    color: var(--md-sys-color-on-surface); /* Ensure heading colors match */
    margin-top: 1.5em;
    margin-bottom: 0.5em;
  }
  .article-content h1 {
    font-size: 2em; /* Adjust as needed */
  }
  .article-content h2 {
    font-size: 1.6em;
  }
  .article-content h3 {
    font-size: 1.3em;
  }

  .article-content p {
    margin-bottom: 1em;
  }

  .article-content a {
    color: var(--md-sys-color-primary);
    text-decoration: underline;
  }
  .article-content a:hover {
    text-decoration: none;
  }

  .article-content ul,
  .article-content ol {
    margin-left: 2em;
    margin-bottom: 1em;
  }

  .article-content li {
    margin-bottom: 0.5em;
  }

  .article-content strong {
    font-weight: 600; /* Or your theme's bold weight */
  }

  /* Adjust margins specific to the body element within Base.astro if needed */
  /* For example, Base.astro might have padding on its main slot area. */
  /* You might need to adjust for that, or ensure Base.astro's direct slot doesn't add conflicting padding. */
  /* However, since we are putting <main class="article-content"> *inside* Base's slot, it should work well. */

  @media (max-width: 768px) {
    .article-content {
      padding: 1.5em;
      margin: 1em;
    }
    .article-content h1 {
      font-size: 1.8em;
    }
    .article-content h2 {
      font-size: 1.5em;
    }
  }
</style>

```
---

`src/layout/Base.astro`:
```
---
import Header from "../components/Header.astro";
import "../styles/global.css";
import "../styles/light.css";
import "../styles/dark.css";
import { ClientRouter } from 'astro:transitions';

interface Props {
  title: string;
}

const { title } = Astro.props;

const isLoggedIn = !!Astro.locals.userId;

import '@fontsource-variable/open-sans';
import '@fontsource/amiri';
import '@fontsource-variable/eb-garamond';
import Footer from "../components/Footer.astro";

---

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>{title}</title>
    <ClientRouter />
    <meta name="viewport" content="width=device-width" />
  </head>
  <body>
    <Header isLoggedIn={isLoggedIn} />
    <slot />
    <Footer />
  </body>
</html>
```
---

`src/lib/apiHelpers.ts`:
```
// src/lib/apiHelpers.ts
import type { PostgrestError } from "@supabase/supabase-js";
import { AuthError } from "@supabase/supabase-js";

export function handleSupabaseError(error: PostgrestError, message: string) {
  console.error(message, error);
  return new Response(
    JSON.stringify({
      error: message,
      details: error.message,
    }),
    { status: 500, headers: { "Content-Type": "application/json" } },
  );
}

export function handleCountError(error: any, message: string) {
    console.error(message, error);
    return new Response(
        JSON.stringify({
            error: message,
            details: error.message || "Unknown error",
        }),
        { status: 500, headers: { 'Content-Type': 'application/json' } }
    );
}

export function handleRequestError(error: any, message: string) {
    console.error(message, error);
    return new Response(
        JSON.stringify({
          error: message,
          details: error.message || 'Invalid Request',
        }),
        { status: 400, headers: { 'Content-Type': 'application/json' } }
    );
  }

export function handleAuthError(error: AuthError, message: string) {
  console.error(message, error);
  return new Response(
    JSON.stringify({
      error: message,
      details: error.message,
    }),
    { status: 500, headers: { "Content-Type": "application/json" } },
  );
}
```
---

`src/lib/auth.ts`:
```
// src/lib/auth.ts
import type { AstroCookies } from "astro";
import { supabase } from "./supabase";

export function setAuthCookies(
  cookies: AstroCookies,
  access_token: string,
  refresh_token: string,
) {
  cookies.set("sb-access-token", access_token, {
    sameSite: "strict",
    path: "/",
    secure: true,
    httpOnly: true,
  });
  cookies.set("sb-refresh-token", refresh_token, {
    sameSite: "strict",
    path: "/",
    secure: true,
    httpOnly: true,
  });
}

export function clearAuthCookies(cookies: AstroCookies) {
  cookies.delete("sb-access-token", { path: "/" });
  cookies.delete("sb-refresh-token", { path: "/" });
}

export async function checkAndSetSession(cookies: AstroCookies, locals?: App.Locals) {
    const refreshToken = cookies.get("sb-refresh-token");

    if (!refreshToken) {
        return false;
    }

    const { data: { session }, error } = await supabase.auth.getSession();

    if (error || !session) {
        clearAuthCookies(cookies);
        return false;
    }

    if(session.access_token !== cookies.get("sb-access-token")?.value || session.refresh_token !== cookies.get("sb-refresh-token")?.value){
        setAuthCookies(cookies, session.access_token, session.refresh_token);
    }


    if (locals && session.user) {
        locals.email = session.user.email ?? "";
        locals.name = session.user.user_metadata?.name ?? "";
        locals.avatar_url = session.user.user_metadata?.avatar_url ?? "";
        locals.userId = session.user.id;
        locals.createdAt = session.user.created_at;
        locals.school = session.user.user_metadata?.school ?? "";
        locals.phone = session.user.user_metadata?.phone ?? "";
        locals.is_participant = session.user.user_metadata?.is_participant ?? false;
        locals.is_visible = session.user.user_metadata?.is_visible ?? false;
    }

    return true;
}
```
---

`src/lib/supabase.ts`:
```
// src/lib/supabase.ts
import { createClient } from "@supabase/supabase-js";

export const supabase = createClient(
  import.meta.env.SUPABASE_URL,
  import.meta.env.SUPABASE_ANON_KEY,
  {
    auth: {
      flowType: "pkce",
      autoRefreshToken: true,
      persistSession: true,
    },
  },
);
```
---

`src/middleware/index.ts`:
```
// src/middleware/index.ts
import { defineMiddleware } from "astro:middleware";
import micromatch from "micromatch";
import { checkAndSetSession, clearAuthCookies } from "../lib/auth";
import { supabase } from "../lib/supabase";

const protectedRoutes = [
    "/dashboard(|/)",
    "/competition",
    "/competition/**",
];
const redirectRoutes = ["/signin(|/)", "/register(|/)"];
const protectedAPIRoutes = ["/api/answers(|/)", "/api/profile(|/)"];

export const onRequest = defineMiddleware(
  async ({ locals, url, cookies, redirect }, next) => {
    // Always attempt to set session data for ALL requests if cookies are present.
    // This will populate Astro.locals if the user is logged in.
    const isUserLoggedIn = await checkAndSetSession(cookies, locals);

    if (micromatch.isMatch(url.pathname, protectedRoutes)) {
      if (!isUserLoggedIn) {
        // The route is protected and user is not logged in, redirect.
        return redirect("/signin");
      }
    }

    if (micromatch.isMatch(url.pathname, redirectRoutes)) {
      if (isUserLoggedIn) {
        // Route is a signin/register page and user is logged in, redirect.
        return redirect("/dashboard");
      }
    }

    if (micromatch.isMatch(url.pathname, protectedAPIRoutes)) {
      // For protected API routes, if Astro.locals.userId wasn't populated by checkAndSetSession,
      // it means the user is not authenticated.
      if (!locals.userId) {
        return new Response(
          JSON.stringify({
            error: "Unauthorized",
          }),
          { status: 401, headers: { "Content-Type": "application/json" } },
        );
      }
      // locals.userId is already available if isUserLoggedIn was true.
    }

    return next();
  },
);
```
---

`src/pages/dashboard.astro`:
```
---
// src/pages/dashboard.astro
import Form from "../components/Form.astro";
import Base from "../layout/Base.astro";
import Profile from "../components/Profile.astro";
import WelcomeCompetitionPrompt from "../components/WelcomeCompetitionPrompt.astro";
const { name, school, phone, is_participant, is_visible } = Astro.locals;
---

<Base title="Dashboard">
  <WelcomeCompetitionPrompt userName={name} isParticipant={is_participant} />
  <Profile />
  <md-text-button class="logout" href="/api/auth/signout">KELUAR</md-text-button
  >
  <Form
    userName={name}
    userSchool={school}
    userPhone={phone}
    userIsVisible={is_visible}
  />
</Base>

<script>
  import "material/dialog/dialog";
  import "material/button/text-button";
</script>

<style>
  md-text-button {
    font-family: "Open Sans Variable", sans-serif;
    --md-text-button-label-text-color: var(--md-sys-color-error);
  }
</style>

```
---

`src/pages/index.astro`:
```
---
// src/pages/index.astro

import Base from "../layout/Base.astro";
import Ayat from "../images/ayat.svg";
import { Icon } from "astro-icon/components";
import CompetitionAnnouncement from "../components/CompetitionAnnouncement.astro";

const isLoggedIn = !!Astro.locals.userId;
const isParticipant = !!Astro.locals.is_participant;
---

<Base title="Faraid Academy - Home">
  <main class="col">
    <div class="main-text col">
      <div class="main-verse col">
        <div class="verse row">
          <Icon class="flip" name="parenthesis" size="1.5em" />
          <Ayat height="3em" ; fill="currentColor" />
          <Icon name="parenthesis" size="1.5em" />
        </div>
        <div class="translation col">
          <p>
            These (inheritance rules) are settled portions <span
              >ordained by Allah</span
            >
            <Icon name="tabarak" />
          </p>
        </div>
      </div>

    </div>
    <CompetitionAnnouncement isLoggedIn={isLoggedIn} isParticipant={isParticipant} />
  </main>
</Base>
<style>
  main {
    gap: 1.5em;
  }
  p {
    text-align: center;
  }

  span {
    display: inline-block;
  }
  .main-text {
    gap: 2em;
    font-family: "EB Garamond Variable", serif;
  }
  .main-verse {
    gap: 0.5em;
    font-size: 1.1em;
  }

  .verse {
    gap: 1em;
    justify-content: center;
  }

  .translation {
    text-wrap: pretty;
    font-size: 0.9em;
  }

  .flip {
    transform: scaleX(-1);
  }

  .main-hadith {
    display: none;
    font-size: 0.6em;
  }

  .hadith {
    font-family: "Amiri", serif;
    font-size: 1.3em;
  }

  [data-icon="tabarak"] {
    vertical-align: middle;
  }

  @media (min-width: 900px) {

  }
</style>

```
---

`src/pages/privacy.md`:
```
---
layout: ../layout/ArticleLayout.astro
title: Privacy Policy - Faraid Academy
---


# Privacy Policy

**Last Updated:** May 22, 2025

Faraid Academy ("we," "us," or "our") operates Faraid Academy (the "Service"). This Privacy Policy informs you of our policies regarding the collection, use, and disclosure of personal data when you use our Service and the choices you have associated with that data. This Service is a personal project.

We use your data to provide and improve the Service. By using the Service, you agree to the collection and use of information in accordance with this policy.

**1. Information We Collect and How We Use It**

We collect several different types of information for various purposes to provide and improve our Service to you.

**A. Information You Provide Directly:**

*   **Account Registration (via Google OAuth):**
    *   **Email Address:** Used as a unique identifier for your account, for communication (e.g., password resets, important service notices, changes to terms/policy), and to associate your competition data.
    *   **Name:** Pre-filled from your Google account. You can edit this in your profile. Used for personalization and, if you opt-in, for display in competition results.
    *   **Avatar URL (Profile Picture):** Pre-filled from your Google account. Used for display in your profile and, if you opt-in, for display in competition results.
*   **Profile Information (Optional, user-editable):**
    *   **School/University:** To understand our user base and potentially for display in competition leaderboards.
    *   **Phone Number:** Optional, for contact purposes if needed (e.g., for significant competition matters, though email is primary).
    *   **Gender:** Optional, for demographic understanding or specific competition categories if applicable.
    *   **Visibility Preference :** A boolean flag you set to determine if your name and avatar are displayed publicly in participant lists or competition results.
*   **Competition Participation:**
    *   **Participation Status:** A boolean flag indicating your intent to join or participate in competitions. This can be set upon login with "join competition" intent or through explicit actions on the site.
    *   **Answers to Competition Questions:** When you participate in a competition, we collect your answers to the questions. This data is linked to your user ID to score your performance and for you to review your results.

**B. Information Collected Automatically:**

*   **Authentication Data (via Supabase):**
    *   **User ID:** A unique ID assigned by Supabase upon account creation.
    *   **Account Creation Date:** The date your account was created.
*   **Cookies and Local Storage:**
    *   **Authentication Cookies:** Used by Supabase to manage your login session securely. These are essential for the Service to function for logged-in users. These are HTTP-only cookies.
    We do not use cookies for tracking purposes beyond essential authentication and user preferences as described. We do not use third-party analytics cookies.

**2. How We Use Your Information**

We use the collected data for various purposes:

*   To provide and maintain our Service (e.g., authenticate you, display your profile).
*   To manage your participation in competitions (e.g., record answers, calculate scores, display results).
*   To notify you about changes to our Service or policies.
*   To allow you to participate in interactive features of our Service when you choose to do so.
*   To personalize your experience on the Service.
*   To respond to your inquiries and provide support.
*   For internal record keeping and service improvement.

**3. How We Share Your Information**

We do not sell your personal data. We may share your information in the following limited circumstances:

*   **With Service Providers:**
    *   **Supabase:** We use Supabase for database hosting, user authentication, and backend services. Supabase stores your profile data, competition results, and authentication information. Their privacy policy governs their use of data.
    *   **Google (OAuth):** If you sign in using Google, Google shares your email, name, and avatar URL with us as per your Google account permissions.
*   **Competition Results:** If you participate in a competition and have your `is_visible` setting enabled, your name and avatar URL may be displayed in public leaderboards or lists of participants. If `is_visible` is disabled, your identity will not be publicly linked to your results, though your participation will still be recorded for scoring.
*   **Legal Requirements:** We may disclose your Personal Data in the good faith belief that such action is necessary to:
    *   To comply with a legal obligation.
    *   To protect and defend the rights or property of Afif Zaki.
    *   To prevent or investigate possible wrongdoing in connection with the Service.
    *   To protect the personal safety of users of the Service or the public.
    *   To protect against legal liability.

**4. Data Retention**

*   **User Account and Profile Data:** We will retain your personal profile data (name, email, school, phone, gender, avatar URL, visibility settings, participant status) for as long as your account is active. If your account is inactive for a period of **one (1) year**, we may delete your account and associated profile data.
*   **Competition Data (Answers & Scores):** Your answers to competition questions and resulting scores linked to your user ID will be retained **indefinitely**. This allows past participants to review their scores and performance. If you request account deletion, we will anonymize this competition data if feasible, or delete it if anonymization is not practical while still preserving the integrity of overall competition statistics.
*   **Local Storage Data:** Data stored in your browser's local storage (theme, prompt dismissal) remains until you clear your browser's cache/data.

**5. Your Data Rights**

You have certain rights regarding your personal data:

*   **Access and Correction:** You can access and update most of your profile information (name, school, phone, gender, visibility) directly through your dashboard/profile settings on the Service. For access to other data, please contact us.
*   **Deletion:** You can request the deletion of your account and associated personal data by contacting us at faraidacademy@gmail.com. Upon such a request, we will delete your profile information and take steps regarding your competition data as described in the "Data Retention" section.
*   **Opt-out of Visibility:** You can control whether your name and avatar are publicly displayed in competition results or participant lists by toggling the `is_visible` setting in your profile.

**6. Data Security**

The security of your data is important to us. We rely on the security measures implemented by our service provider, Supabase, for data storage and authentication. We also implement "common sense" security practices appropriate for a personal project. However, remember that no method of transmission over the Internet or method of electronic storage is 100% secure. While we strive to use commercially acceptable means to protect your Personal Data, we cannot guarantee its absolute security.

**7. Children's Privacy**

Our Service is primarily intended for university students and individuals above high school age. It is not directed to individuals under the age of 16 ("Children"). We do not knowingly collect personally identifiable information from children under 16. If you are a parent or guardian and you are aware that your Child has provided us with Personal Data, please contact us. If we become aware that we have collected Personal Data from children without verification of parental consent, we will take steps to remove that information from our servers.

**8. International Data Transfers**

Your information, including Personal Data, may be transferred to — and maintained on — computers located outside of your state, province, country, or other governmental jurisdiction where the data protection laws may differ from those of your jurisdiction. Our service provider, Supabase, utilizes a global infrastructure. If you are located outside Indonesia and choose to provide information to us, please note that we transfer the data, including Personal Data, to be processed where Supabase servers are located and in Indonesia where the operator is based. Your consent to this Privacy Policy followed by your submission of such information represents your agreement to that transfer.

**9. Changes to This Privacy Policy**

We may update our Privacy Policy from time to time. We will notify you of any material changes by posting the new Privacy Policy on this page and by sending an email to the address associated with your account. You are advised to review this Privacy Policy periodically for any changes. Changes to this Privacy Policy are effective when they are posted on this page.

**10. Governing Law**

This Privacy Policy is governed by the laws of Indonesia.

**11. Contact Us**

If you have any questions about this Privacy Policy, please contact us:
*   By email: faraidacademy@gmail.com

---

Afif Zaki
Operator, Faraid Academy
```
---

`src/pages/signin.astro`:
```
---
// src/pages/signin.astro
import Base from "../layout/Base.astro";
import AuthForm from "../components/AuthForm.astro";
const title = "Log in";

---

<Base title={title}>
  <main>
    <section>
      <AuthForm showProviderButtons />
    </section>
  </main>
</Base>
```
---

`src/pages/terms.md`:
```
---
layout: ../layout/ArticleLayout.astro
title: Terms of Service - Faraid Academy
---

# Terms of Service

**Last Updated:** May 22, 2025

Welcome to Faraid Academy! These Terms of Service ("Terms") govern your use of the Faraid Academy website, including all content, features, and services offered (collectively, the "Service"). Faraid Academy is a personal educational project created and operated by Muhammad Siddiq, an individual.

By accessing or using the Service, you agree to be bound by these Terms. If you do not agree to these Terms, please do not use the Service.

**1. About Faraid Academy**

Faraid Academy is an educational platform primarily focused on Islamic inheritance law. It may also host competitions related to its educational content. The Service is a personal project intended for educational purposes.

**2. User Accounts**

*   **Registration:** To access certain features of the Service, such as participating in competitions or saving profile information, you may need to create an account, typically through Google OAuth.
*   **Account Responsibility:** You are responsible for maintaining the confidentiality of your account information and for all activities that occur under your account. You agree to notify us immediately of any unauthorized use of your account.
*   **Accuracy of Information:** You agree to provide accurate, current, and complete information during the registration process and to update such information to keep it accurate, current, and complete.

**3. User Conduct**

You agree to use the Service only for lawful purposes and in a manner that does not infringe the rights of, restrict, or inhibit anyone else's use and enjoyment of the Service. Prohibited behavior includes, but is not limited to:
*   Violating any applicable laws or regulations.
*   Providing false or misleading information.
*   Harassing, abusing, or harming another person.
*   Attempting to disrupt or interfere with the Service's security or functionality.
*   Using any automated system, such as "bots," "spiders," or "offline readers," to access the Service in a manner that sends more request messages to our servers than a human can reasonably produce in the same period by using a conventional web browser.

**4. Competitions**

*   **Competition Rules:** From time to time, Faraid Academy may host competitions. Each competition will have its own specific rules, guidelines, and eligibility requirements, which will be detailed in a competition guide (e.g., `competition-guide.md`). By participating in a competition, you agree to abide by its specific rules.
*   **Fair Play:** Participants in any Faraid Academy competition are expected to uphold the highest standards of sportsmanship and academic honesty. Cheating, plagiarism, collusion, or any other form of academic dishonesty is strictly prohibited and may result in disqualification and/or account suspension. This is especially critical for timed competitions.
*   **Results:** Competition results, which may include participant names and profile pictures (if `is_visible` is enabled by the user), may be published on the Service.

**5. Intellectual Property**

*   **Our Content:** All content provided on the Service, including text, graphics, logos, icons, images, audio clips, digital downloads, data compilations, software, and competition questions, is the property of Muhammad Siddiq or its content suppliers and protected by international copyright laws. You may not modify, copy, distribute, transmit, display, perform, reproduce, publish, license, create derivative works from, transfer, or sell any information, software, products, or services obtained from the Service without our prior written consent.
*   **User Content:** You retain ownership of any personal information you submit to the Service, subject to the rights granted to us in these Terms and the Privacy Policy. You are solely responsible for the accuracy and legality of your User Content.

**6. Third-Party Services**

The Service utilizes third-party services for authentication and data storage:
*   **Google OAuth:** For user sign-in. Your use of Google OAuth is subject to Google's Terms of Service and Privacy Policy.
*   **Supabase:** For backend database and authentication services.

We are not responsible for the practices of these third-party services.

**7. Disclaimers and Limitation of Liability**

*   **"As-Is" Basis:** The Service is provided on an "as-is" and "as-available" basis. We make no representations or warranties of any kind, express or implied, as to the operation of the Service or the information, content, materials, or products included on the Service. You expressly agree that your use of the Service is at your sole risk.
*   **No Guarantee of Uptime or Accuracy:** While we strive to maintain the Service, we do not guarantee that it will be uninterrupted, error-free, or completely secure. As a personal project operated by an individual, resources are limited, and occasional downtime or inaccuracies may occur.
*   **Educational Content:** Information provided on Faraid Academy is for educational purposes only and should not be considered professional legal or financial advice.
*   **Limitation of Liability:** To the fullest extent permitted by applicable law, Muhammad Siddiq shall not be liable for any indirect, incidental, special, consequential, or punitive damages, or any loss of profits or revenues, whether incurred directly or indirectly, or any loss of data, use, goodwill, or other intangible losses, resulting from (a) your access to or use of or inability to access or use the Service; (b) any conduct or content of any third party on the Service; or (c) unauthorized access, use, or alteration of your transmissions or content.

**8. Account Suspension and Termination**

We reserve the right to suspend or terminate your access to the Service at our sole discretion, without notice or liability, for any reason, including but not limited to:
*   A breach of these Terms.
*   Conduct that we deem "unruly," harmful to other users, the Service, or third parties.
*   Illegal activities.
*   Prolonged inactivity (as defined in our Privacy Policy regarding data retention).

**9. Changes to Terms**

We may revise these Terms from time to time. The most current version will always be posted on our website. If a revision, in our sole discretion, is material, we will notify you via the email address associated with your account or by posting a notice on the Service. By continuing to access or use the Service after revisions become effective, you agree to be bound by the revised Terms.

**10. Governing Law and Dispute Resolution**

These Terms shall be governed and construed in accordance with the laws of Indonesia, without regard to its conflict of law provisions. Any disputes arising out of or relating to these Terms or the Service shall be resolved amicably through discussion. If a resolution cannot be reached, disputes will be subject to the exclusive jurisdiction of the courts located in Indonesia.

**11. Contact Us**

If you have any questions about these Terms, please contact us at:
faraidacademy@gmail.com

---


Operator, Faraid Academy
```
---

`src/pages/api/answers.ts`:
```
// src/pages/api/answers.ts
import type { APIRoute } from "astro";
import { supabase } from "../../lib/supabase";
import { handleSupabaseError, handleRequestError } from "../../lib/apiHelpers";

export const POST: APIRoute = async ({ request, locals, redirect }) => {
  console.log("API Route /api/answers: locals:", locals); // Keep this log

  try {
    const { questionId, answerId } = await request.json();

    // Validate input (important for security and data integrity)
    if (!questionId || (answerId === undefined)) {
      return new Response(
        JSON.stringify({ error: "questionId and answerId are required" }),
        { status: 400, headers: { 'Content-Type': 'application/json' } },
      );
    }

    // Use upsert to insert or update the result
    const { error } = await supabase
      .from("results")
      .upsert(
        {
          user_id: locals.userId,
          question_id: questionId,
          answer_id: answerId,
        },
        { onConflict: 'user_id,question_id' }
      )
      .select();

    if (error) {
      return handleSupabaseError(error, "Failed to save answer"); // Use the helper
    }

    return new Response(JSON.stringify({ success: true }), { status: 200, headers: { 'Content-Type': 'application/json' } });
  } catch (error) {
    return handleRequestError(error, "Invalid request body"); // Use new helper
  }
};
```
---

`src/pages/api/profile.ts`:
```
// src/pages/api/profile.ts
import type { APIRoute } from "astro";
import { supabase } from "../../lib/supabase";
import { handleRequestError, handleAuthError } from "../../lib/apiHelpers";

export const POST: APIRoute = async ({ request, locals }) => {
  try {
    const requestData = await request.json();
    const updateData: { [key: string]: any } = {};
    if ('name' in requestData) updateData.name = requestData.name;
    if ('school' in requestData) updateData.school = requestData.school;
    if ('phone' in requestData) updateData.phone = requestData.phone;
    if ('is_participant' in requestData) updateData.is_participant = requestData.is_participant;
    if ('is_visible' in requestData) updateData.is_visible = requestData.is_visible;

    if (Object.keys(updateData).length === 0) {
      return new Response(JSON.stringify({ message: "No data provided to update" }), {
        status: 400,
        headers: { "Content-Type": "application/json" },
      });
    }

    const { error } = await supabase.auth.updateUser({
      data: updateData,
    });

    if (error) {
      return handleAuthError(error, "Failed to update profile");
    }

    return new Response(JSON.stringify({ success: true }), {
      status: 200,
      headers: { "Content-Type": "application/json" },
    });
  } catch (error) {
    return handleRequestError(error, "Invalid request body");
  }
};
```
---

`src/pages/api/auth/callback.ts`:
```
// src/pages/api/auth/callback.ts
import type { APIRoute } from "astro";
import { supabase } from "../../../lib/supabase";

export const GET: APIRoute = async ({ url, cookies, redirect }) => {
  const authCode = url.searchParams.get("code");
  const intent = url.searchParams.get("intent"); // intent from URL

  if (!authCode) {
    return new Response("No code provided", { status: 400 });
  }

  const { data, error } = await supabase.auth.exchangeCodeForSession(authCode);

  if (error) {
    return new Response(error.message, { status: 500 });
  }

  const { access_token, refresh_token, user } = data.session;

  cookies.set("sb-access-token", access_token, {
    path: "/",
    secure: !import.meta.env.DEV, // only in production
    httpOnly: true,
    sameSite: "lax", // 'lax' or 'strict' based on your needs
  });
  cookies.set("sb-refresh-token", refresh_token, {
    path: "/",
    secure: !import.meta.env.DEV, // only in production
    httpOnly: true,
    sameSite: "lax", // 'lax' or 'strict'
  });

  // If intent is to join competition, update user metadata
  if (intent === "join_competition" && user) {
    const { error: updateError } = await supabase.auth.updateUser({
      data: { is_participant: true }
    });
    if (updateError) {
      // Log error. The user will still be logged in, might see the WelcomeCompetitionPrompt as a fallback.
      console.error("Failed to auto-set is_participant in callback:", updateError.message);
    }
    // User's session will be updated on the next request by the middleware (checkAndSetSession)
  }

  // Create a new URL object for the /dashboard page
  const redirectUrl = new URL('/dashboard', url.origin);

  // Redirect to the cleaned URL
  return redirect(redirectUrl.toString());
};
```
---

`src/pages/api/auth/signin.ts`:
```
// src/pages/api/auth/signin.ts
import type { APIRoute } from "astro";
import { supabase } from "../../../lib/supabase";
import type { Provider } from "@supabase/supabase-js";

export const POST: APIRoute = async ({ request, redirect }) => {
  const formData = await request.formData();
  const provider = formData.get("provider")?.toString();
  const intent = formData.get("intent")?.toString(); // Add this

  if (provider) {
    const baseCallbackUrl = import.meta.env.DEV
      ? "http://localhost:4321/api/auth/callback"
      : "https://faraidacademy.netlify.app/api/auth/callback";

    let redirectToUrl = baseCallbackUrl;
    if (intent === "join_competition") { // Check intent
      redirectToUrl += "?intent=join_competition"; // Append to URL
    }

    const { data, error } = await supabase.auth.signInWithOAuth({
      provider: provider as Provider,
      options: {
        redirectTo: redirectToUrl, // Use the potentially modified URL
      },
    });

    if (error) {
      return new Response(error.message, { status: 500 });
    }

    return redirect(data.url);
  }

  return new Response("Provider required", { status: 400 });
};
```
---

`src/pages/api/auth/signout.ts`:
```
// src/pages/api/auth/signout.ts
import type { APIRoute } from "astro";
import { clearAuthCookies } from "../../../lib/auth"; // Import

export const GET: APIRoute = async ({ cookies, redirect }) => {
  clearAuthCookies(cookies); // Use helper
  return redirect("/signin");
};
```
---

`src/pages/competition/index.astro`:
```
---
import Base from "../../layout/Base.astro";
import { Icon } from "astro-icon/components";
import Countdown2 from "../../components/Countdown2.astro";
import { Content as CompetitionGuideContent, frontmatter as guideFrontmatter } from "../../content/guides/competition-guide.md";

const competitionStartDate = "2025-06-17T11:00:00Z";
---

<Base title="Faraid Competition">
  <main class="col">
    <section class="competition-main-page col">
      <Icon name="trophy2" size="3em" />
      <h1>Faraid Competition<wbr /> 2025</h1>

      <div class="start-info col">
        <p>Akan dimulai dalam:</p>
        <div class="countdown-wrapper">
          <Countdown2 targetTime={competitionStartDate} />
        </div>

        <div class="start-time-details" data-start-date={competitionStartDate}>
          <p class="date-info-line">
            <Icon name="material-symbols:calendar-month-rounded" size="1.1em" />
            <span class="local-date-text">Memuat tanggal...</span>
          </p>
          <p class="time-info-line">
            <Icon name="material-symbols:schedule-outline-rounded" size="1.1em" />
            <span class="local-time-text start-time-clock">Memuat waktu...</span>
          </p>
        </div>
      </div>

      <div class="actions row">
        <md-outlined-button id="open-guides-dialog">
          <Icon name="material-symbols:help-outline-rounded" slot="icon" />
          Info & Panduan
        </md-outlined-button>

        <md-filled-button href="/competition/1" trailing-icon>
          Mulai
          <Icon name="material-symbols:play-arrow-rounded" slot="icon" />
        </md-filled-button>
      </div>
    </section>

    <md-dialog id="guides-dialog">
      <div slot="headline" class="row dialog-headline">
        <Icon name="material-symbols:menu-book-rounded" size="1.2em" />
        {guideFrontmatter.title}
      </div>
      <div slot="content" id="guides-content" class="col">
        <CompetitionGuideContent />
      </div>
      <div slot="actions">
        <md-text-button id="close-guides-dialog" value="close">
          Tutup
        </md-text-button>
      </div>
    </md-dialog>
  </main>
</Base>
<style is:global>
  .countdown-container{
    gap:2em;
  }
</style>
<style>
  [data-icon="material-symbols:play-arrow-rounded"] {
    color: var(--md-sys-color-on-primary);
  }

  main.col {
    padding-top: 2em;
    padding-bottom: 2em;
    gap: 2em;
    width: 100%;
  }
  h1 {
    text-wrap: pretty;
    font-size: 1.1em;
  }
  .start-info {
    gap: 0.75em;
    margin-bottom: 1em;
  }

 .start-info[data-astro-cid-zptrxzxo]>p[data-astro-cid-zptrxzxo]:first-child {
    margin-bottom: 0;
    font-size: 0.8em;
    color: var(--md-sys-color-on-surface-variant);
}

  .start-time-details {
    font-size:0.8em;
    display: flex;
    flex-direction: row;
    align-items: center;
    gap: 1em;
    width: 100%;
    justify-content: center;
  }

  .date-info-line,
  .time-info-line {
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: center;
    gap: 0.2em;
    font-size: 0.9em;
    color: var(--md-sys-color-on-surface-variant);
    opacity: 0.9;
    margin: 0;
  }

  .actions {
    gap: 1em;
    justify-content: center;
    flex-wrap: wrap;
    margin-top: 1em;
  }

  md-outlined-button,
  md-filled-button {
    min-width: 160px;
    --md-filled-button-label-text-font-weight: 500;
    --md-outlined-button-label-text-font-weight: 500;
  }

  #guides-dialog {
    margin: auto;
  }

  .dialog-headline {
    gap: 0.5em;
    align-items: center;
  }

  /* These styles should now apply to the content rendered from Markdown */
  #guides-dialog div[slot="content"] {
    gap: 0.8em;
    padding-top: 0.5em;
    padding-bottom: 1em;
  }

  /*
    You might need to adjust these selectors slightly if the Markdown
    output structure is different, but Astro's default Markdown
    output typically wraps paragraphs in <p> tags.
  */
  #guides-dialog div[slot="content"] :global(p) { /* Use :global if styles are scoped */
    text-align: left;
    line-height: 1.6;
    font-size: 0.95em;
    color: var(--md-sys-color-on-surface-variant);
    margin-block-start: 0; /* Reset default paragraph margins if needed */
    margin-block-end: 0.8em; /* Or keep your gap for spacing */
  }
  #guides-dialog div[slot="content"] :global(p:last-child) {
    margin-block-end: 0;
  }

  #guides-dialog div[slot="content"] :global(strong) {
    color: var(--md-sys-color-on-surface);
    font-weight: 600;
  }
</style>

<script>
  // Your existing script remains the same
  import "material/dialog/dialog.js";
  import "material/button/outlined-button.js";
  import "material/button/filled-button.js";
  import "material/button/text-button.js";

  type DialogLikeElement = HTMLElement & {
    open?: boolean;
    show?: () => void;
    showModal?: () => void;
    close: (reason?: string) => void;
    returnValue?: string;
  };

  function formatUTCDateToLocalParts(utcDateString: string):
    { datePart: string; timePart: string } |
    { error: string }
  {
    const date = new Date(utcDateString);
    if (isNaN(date.getTime())) {
      return { error: "Invalid date" };
    }

    const dateOptions: Intl.DateTimeFormatOptions = {
      weekday: 'long',
      year: 'numeric',
      month: 'long',
      day: 'numeric',
    };
    const datePart = date.toLocaleDateString('id-ID', dateOptions);

    const timeOptions: Intl.DateTimeFormatOptions = {
      hour: '2-digit',
      minute: '2-digit',
      hour12: false,
    };
    const timePart = date.toLocaleTimeString('en-GB', timeOptions); // Or 'id-ID' if you prefer localized time format for display

    return { datePart, timePart };
  }

  document.addEventListener("astro:page-load", () => {

    const guidesDialog = document.getElementById(
      "guides-dialog",
    ) as DialogLikeElement | null;
    const openGuidesButton = document.getElementById("open-guides-dialog");
    const closeGuidesButton = document.getElementById("close-guides-dialog");

    if (openGuidesButton && guidesDialog) {
      openGuidesButton.addEventListener("click", () => {
        if (typeof guidesDialog.show === "function") {
          guidesDialog.show();
        } else if (typeof guidesDialog.showModal === "function") {
          guidesDialog.showModal();
        } else {
          guidesDialog.open = true;
        }
      });
    }

    if (closeGuidesButton && guidesDialog) {
      closeGuidesButton.addEventListener("click", () => {
        if (typeof guidesDialog.close === "function") {
          guidesDialog.close();
        }
      });
    }

    const startTimeDetailsElement = document.querySelector<HTMLElement>(".start-time-details");

    if (startTimeDetailsElement) {
      const dateTextSpan = startTimeDetailsElement.querySelector<HTMLSpanElement>(".local-date-text");
      const timeTextSpan = startTimeDetailsElement.querySelector<HTMLSpanElement>(".local-time-text.start-time-clock");
      const utcDateString = startTimeDetailsElement.dataset.startDate;

      if (dateTextSpan && timeTextSpan) {
        if (utcDateString) {
          const result = formatUTCDateToLocalParts(utcDateString);
          if ('error' in result) {
            dateTextSpan.textContent = result.error;
            timeTextSpan.textContent = "Kesalahan waktu";
          } else {
            dateTextSpan.textContent = result.datePart;
            timeTextSpan.textContent = result.timePart;
          }
        } else {
          dateTextSpan.textContent = "Tanggal kompetisi tidak tersedia.";
          timeTextSpan.textContent = "";
          console.error("Attribute data-start-date tidak ditemukan pada .start-time-details");
        }
      } else {
        if (!dateTextSpan) console.error("Elemen .local-date-text tidak ditemukan dalam .start-time-details.");
        if (!timeTextSpan) console.error("Elemen .local-time-text.start-time-clock tidak ditemukan dalam .start-time-details.");
        // Avoid overwriting the whole container if only one part is missing, or handle more gracefully
        // For example, if startTimeDetailsElement has other important children.
        // startTimeDetailsElement.textContent = "Kesalahan dalam menampilkan waktu kompetisi.";
      }
    }
  });
</script>
```
---

`src/pages/competition/[id].astro`:
```
---
import Countdown from "../../components/Countdown.astro";
import Base from "../../layout/Base.astro";
import { supabase } from "../../lib/supabase";
import type { Question, Answer } from "../../types";
import { Icon } from "astro-icon/components";

const { id } = Astro.params;

if (!id || isNaN(Number(id))) {
  return Astro.redirect("/404");
}

const questionId = Number(id);

const { data: questionData, error: questionError } = await supabase
  .from("questions")
  .select("id, question, money, case")
  .eq("id", questionId)
  .single();

if (questionError) {
  return Astro.redirect("/404");
}

if (!questionData) {
  return Astro.redirect("/404");
}

const { data: answersData, error: answersError } = await supabase
  .from("answers")
  .select("id, question_id, answer")
  .eq("question_id", questionId);

if (answersError) {
  return Astro.redirect("/404");
}

function shuffleArray(array: any[]) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
}

const question: Question = questionData;
const answers: Answer[] = answersData || [];
shuffleArray(answers);

const { count: totalQuestionCount, error: countError } = await supabase
  .from("questions")
  .select('*', { count: 'exact', head: true });

if (countError || totalQuestionCount === null) {
  console.error("Error fetching question count:", countError);
  return Astro.redirect("/competition");
}

let userResult = undefined;
let userHasAnswered = false;

if (Astro.locals.userId) {
  const { data: resultExistsData, error: resultExistsError } = await supabase
    .from("results")
    .select("id")
    .eq("user_id", Astro.locals.userId)
    .eq("question_id", questionId)
    .single();

  if (resultExistsError && resultExistsError.code !== "PGRST116") {
    console.error("Error checking if user has answered:", resultExistsError);
  } else {
    userHasAnswered = !!resultExistsData;
  }

  if (userHasAnswered) {
    const { data: resultData, error: resultError } = await supabase
      .from("results")
      .select("answer_id")
      .eq("user_id", Astro.locals.userId)
      .eq("question_id", questionId)
      .single();

    if (resultError && resultError.code !== "PGRST116") {
      console.error("Error fetching user result:", resultError);
    } else if (resultData) {
      userResult = resultData.answer_id;
    }
  }
}

function formatNumber(num: number | null | undefined): string {
  if (num === null || num === undefined) {
    return "";
  }
  return num.toLocaleString("de-DE");
}

const formattedMoney = formatNumber(question.money);
---

<Base title={`Question ${questionId}`}>
  <md-filled-card class="countdown">
    <Countdown targetTime="2025-06-17T11:00:00Z" format="colon" />
  </md-filled-card>
  <style>
    .countdown {
      padding: 12px;
    }
  </style>
  <md-elevated-card dir="rtl" class="competition-card col">
    <div class="question-area col" data-question-id={questionId}>
      <md-filled-card class="question col">
        <p>{question.question}</p>
        {formattedMoney && <p>التركة: Rp {formattedMoney}</p>}
        <p>السؤال: كم نصيب {question.case}؟</p>
      </md-filled-card>

      <div class="answers col">
        <div
          class="answers-list col"
          role="radiogroup"
          aria-label="Select an Answer"
        >
          {
            answers.map((answer) => (
              <div class="radio-group">
                <md-radio
                  id={`answer-${answer.id}`}
                  name="question-answers"
                  value={String(answer.id)}
                  checked={userResult === answer.id}
                  aria-label={answer.answer}
                />
                <label for={`answer-${answer.id}`}>
                  Rp {formatNumber(Number(answer.answer))}
                </label>
              </div>
            ))
          }
          <div class="radio-group null">
            <md-radio
              id="answer-null"
              name="question-answers"
              value="null"
              checked={userResult === null}
              aria-label="None of the Above"
            >
            </md-radio>
            <label for="answer-null">لا شيء مما سبق</label>
          </div>
        </div>
      </div>
    </div>
    <div class="navigation">
      {
        questionId > 1 && (
          <md-filled-tonal-icon-button href={`/competition/${questionId - 1}`}>
            <Icon name="material-symbols:arrow-forward-rounded" size="2em" />
          </md-filled-tonal-icon-button>
        )
      }

      <p>
        <span id="status-indicator">
          {
            userHasAnswered ? (
              <>
                <Icon name="material-symbols:check-circle-rounded" />
                &nbsp;Tersimpan
              </>
            ) : (
              <>
                <Icon name="material-symbols:warning-rounded" />
                &nbsp;Belum Tersimpan
              </>
            )
          }
        </span>
      </p>
      {
        questionId < totalQuestionCount && (
          <md-filled-tonal-icon-button href={`/competition/${questionId + 1}`}>
            <Icon name="material-symbols:arrow-back-rounded" size="2em" />
          </md-filled-tonal-icon-button>
        )
      }
    </div>
  </md-elevated-card>
</Base>

<script>
  import "material/radio/radio";
  import "material/iconbutton/filled-tonal-icon-button";
  import "material/card/elevated-card";
  import "material/card/filled-card";

  document.addEventListener("astro:page-load", () => {
    const statusIndicator = document.getElementById("status-indicator")!;

    const questionAreaElement = document.querySelector<HTMLElement>("div.question-area");
    const questionId = questionAreaElement
      ? parseInt(questionAreaElement.dataset.questionId || "", 10)
      : null;



    async function submitAnswer(
      questionId: number | null,
      answerId: number | null | string,
    ) {
      if (questionId === null) {
        console.error("Question ID not found!");
        statusIndicator.textContent = "error";
        return;
      }

      const parsedAnswerId =
        answerId === "null"
          ? null
          : typeof answerId === "string"
            ? parseInt(answerId, 10)
            : answerId;

      if (parsedAnswerId === null && answerId !== "null") {
        console.error("Invalid answer ID:", answerId);
        statusIndicator.textContent = "error";
        return;
      }

      try {
        const response = await fetch("/api/answers", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            questionId: questionId,
            answerId: parsedAnswerId,
          }),
        });

        if (!response.ok) {
          const errorData = await response.json();
          const errorMessage = errorData.error || "Failed to save answer";
          throw new Error(errorMessage);
        }

        statusIndicator.textContent = "✅ Tersimpan";
        return true;
      } catch (error) {
        console.error("Error saving answer:", error);
        statusIndicator.textContent = "error";

        if (error instanceof Error) {
          alert(error.message);
        } else {
          alert("An unexpected error occurred.");
        }
        return false;
      }
    }

    const radioGroup = document.querySelector('[role="radiogroup"]');

    radioGroup?.addEventListener("change", async (event) => {
      const target = event.target as HTMLInputElement;

      if (target.tagName === "MD-RADIO") {
        statusIndicator.textContent = "⚠ Belum Tersimpan"; 
        await submitAnswer(questionId, target.value);
      }
    });
  });
</script>

<style is:global>
  body {
    background-image: none;
    background-color: var(--md-sys-color-surface);
  }
  body::before {
    display: none;
  }
</style>

<style lang="css">
  .competition-card {
    width: 90%;
    background-color: none;
    font-family: "Amiri", serif;
    padding: 1em;
  }

  section {
    width: 100%;
  }
.question-area{
  width:100%;
}
  .question {
    gap: 1em;
    width: 100%;
    align-items: flex-start;
    padding: 1em;
  }

  .answers {
    width: 100%;
    align-items: flex-start;
    padding: 1em;
  }

  .navigation {
    display: flex;
    justify-content: space-between;
    width: 100%;
    align-items: center;
  }
  .answers-list {
    align-items: flex-start;
    gap: 0.8em;
  }

  .radio-group {
    display: flex;
    align-items: center;
    gap: 1em;
    font-family: "EB Garamond Variable", serif;
  }

  md-radio {
    display: inline-flex;
  }

  .null {
    font-family: "Amiri", serif;
  }

  #status-indicator {
    display: flex;
    align-items: center;
    color: var(--md-sys-color-on-surface);
    font-family: "Open Sans", sans-serif;
    font-size: 0.7em;
  }

  [data-icon="material-symbols:check-circle-rounded"] {
    color: var(--md-sys-color-primary);
  }

  [data-icon="material-symbols:warning-rounded"] {
    color: var(--md-sys-color-error);
  }

  @media (min-width: 600px) and (max-width: 839px) {
    .competition-card {
      font-size: 1.2em;
    }
  }

  @media (min-width: 840px) {
    .competition-card {
      font-size: 0.8em;
      width: auto;
      gap: 1em;
    }

    .question, .answers{
      width: auto;
    }

    .question-area {
      flex-direction: row;
      gap: 1em;
    }
  }
</style>
```
---
